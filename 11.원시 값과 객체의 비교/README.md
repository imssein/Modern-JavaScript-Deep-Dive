# 11장 원시 값과 객체의 비교

| 원시 타입 (primitive type)              | 객체 타입 (object/reference type)       |
| --------------------------------------- | --------------------------------------- |
| 변경 불가능한 값 (immutable value)      | 변경 가능한 값 (mutable value)          |
| 변수에 할당하면 변수에는 실제 값이 저장 | 변수에 할당하면 변수에는 참조 값이 저장 |

| 원시 값이 복사되어 전달
⇒ 값에 의한 전달(pass by value) | 참조 값이 복사되어 전달
⇒ 참조에 의한 전달 (pass by reference) |

- 자바스크립트는 `**값에 의한 전달**`만 존재
- 공통점: 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에서 동일
- 차이점: 변수에 저장되어 있는 값이 `원시 값`이냐 `참조 값`이냐

## 원시 값

---

### 변경 불가능한 값

---

- 원시 값 = 변경 불가능한 값 = 읽기 전용(read only) 값
- 변경이 불가능하다는 의미
  - 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간, 메모리 공간을 식별하기 위한 이름
  - 값: 변수에 저장된 데이터
    - 원시값 자체를 변경할 수 없다 (O)
    - 변수의 값을 변경할 수 없다 (X)

```jsx
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)은 변경 불가능
// const 키워드를 사용해 선언한 변수에 할당한 객체는 변경 가능
o.a = 1;
console.log(o); // {a: 1}
```

<aside>
💡 **원시 값을 할당한 변수에 새로운 원시 값을 재할당하면?**

메모리 공간에 저장되어 있는 재할당 이전의 `원시 값을 변경하는 것이 아니라` `새로운 메모리 공간을 확보`하고 `재할당한 원시 값을 저장`한 후, `변수는 새롭게 재할당한 원시 값을 가리킨다.`
⇒ 변수가 참조하던 `메모리 공간의 주소가 바귄다.`

</aside>

<aside>
💡 변수가 참조하던 메모리 공간의 주소가 변경된 이유?

원시 값이 변경 불가능하기 때문이다. (불변성)

</aside>

### 불변성 (immutability)

- 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경하는 것
- 원시값을 재할당 할 수 없기 때문에 메모리의 다른 주소를 참조한다.

### 문자열과 불변성

---

<aside>
💡 **유사 배열 객체 (array-like object)

마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 개체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 for문으로 순회 가능\*\*

```jsx
var str = "string";
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING
```

</aside>

```jsx
var str = "string";
// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만, 문자열은 원시 값이므로 변경 x => 에러 발생하지않음
str[0] = "S";
console.log(str); // string
```

### 값에 의한 전달

---

```jsx
var score = 80;
// 값에 의한 전달: 원시 값이 복사되어 잔달
// score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
var copy = score;

console.log(score); // 80
console.log(copy); // 80
console.log(score === copy); // true

// 🚨 score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값
// 🚨 score 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다!!!
score = 100;

console.log(score); // 100
console.log(copy); // 80
console.log(score === copy); // false
```

<aside>
💡 **값에 의한 전달**

변수에는 값이 전달되는 것이 아니라 `메모리 주소가 전달`된다. 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.
전달된 메모리 주소를 통해 `메모리 공간에 접근`하면 `값을 참조`할 수 있다.

</aside>

## 객체

---

<aside>
💡 **자바스크립트 객체의 관리 방식**

프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체를 생성한다. 하지만 자바스크립트는 클래스없이 객체를 생성할 수 있고, 동적으로 프로퍼티와 메서드 추가 가능하다. 이는 사용하기는 편하지만 성능 면에서는 전자에 비해 비효율적인 방식이다.

</aside>

### 변경 가능한 값

---

<aside>
💡 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

</aside>

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 `참조 값(reference value)`에 접근할 수 있다.
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
  - `재할당 x` ⇒ 프로퍼티 동적 추가, 프로퍼티 값 갱신 및 삭제 가능
- **여러 개의 식별자가 하나의 객체를 공유할 수 있음**

<aside>
💡 **얕은 복사(shallow copy)와 깊은 복사(deep copy)**

객체를 프로퍼티 값으로 갖는 객체의 경우,

얕은 복사: 한 단계까지만 복사
깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// npm install lodash로 설치한 후 Node.js 환경에서 실행
const _ = require("lodash");

// 깊은 복사

const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // fasle
```

얕은 복사와 깊은 복사로 생성된 객체 ≠ 원본 객체

⇒ 원본과 복사본은 `참조 값이 다른 별개의 객체`다.

얕은 복사: 객체에 중첩되어 있는 경우 `참조 값`을 복사
깊은 복사: 객체에 `중첩되어 있는 객체`까지 `모두` 복사해서 `원시 값처럼 완전한 복사본`을 만든다.

```jsx
const v = 1;

// 깊은 복사
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// 얕은 복사
const c2 = o;
console.log(c2 === o); // true
```

</aside>

### 참조에 의한 전달

---

```jsx
var person = {
  name: "Lee",
};

// 참조 값을 복사 (얕은 복사)
var copy = person;
```

→ 참조에 의한 전달: 참조 값이 복사되어 전달

- 원본 person을 사본 copy에 할당하면 원본 person의 참조 값을 복사해서 copy에 저장
- 저장된 메모리 주소는 다르지만 `동일한 참조 값`을 갖는다.
  - `동일한 객체`를 가리킨다.
  - 두 개의 식별자가 `하나의 객체를 공유`한다
  - 원본 또는 사본 중 어느 `한쪽에서 객체를 변경`(프로퍼티 값 변경, 추가, 삭제)하면 `서로 영향`을 주고받는다.
