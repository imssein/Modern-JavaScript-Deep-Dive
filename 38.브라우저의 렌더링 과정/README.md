# 38장 브라우저의 렌더링 과정

- 대부분의 프로그래밍 언어: 운영체제나 가상 머신 위에서 실행
- 자바스크립트: 브라우저에서 HTML, CSS와 함께 실행

`parsing`

- 프로그래밍 언어의 문법에 맞게 작성된 `텍스트 문서` → 문자열 `토큰`으로 분해(어휘 분석) → 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 `파스 트리` → 중간 언어인 `바이트코드`를 생성하고 실행

> 💡 토큰: 더는 나눌 수 없는 코드의 기본 요소
> 바이트 코드: 특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드

`render`

- HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 `브라우저에 시각적으로 출력하는 것`

### 브라우저의 렌더링 과정

1. `브라우저`는 렌더링에 필요한 `리소스`(HTML, CSS, 자바스크립트, 이미지, 폰트, 파일 등)를 `요청`하고 `서버`로부터 `응답`을 받는다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 `HTML과 CSS를 파싱`하여 `DOM`과 `CSSOM`을 `생성`하고 이들을 `결합`하여 `렌더 트리를 생성`한다.
3. 브라우저의 `자바스크립트 엔진`은 서버로부터 응답된 `자바스크립트`를 `파싱`하여 `AST`(Abstract Syntax Tree)를 `생성`하고 `바이트코드로 변환`하여 `실행`한다. 이때 자바스크립트는 `DOM API`를 통해 `DOM`이나 `CSSOM`을 변경할 수 있다. 이때 변경된 DOM과 CSSOM은 다시 `렌더 트리로 결합`된다.
4. `렌더 트리`를 기반으로 HTML 요소의 `레이아웃을 계산`하고 브라우저 화면에 `HTML 요소를 페이팅`한다.

## 요청과 응답

---

- 브라우저 주소 창에 https://www.naver.com만 입력해도 기본적으로 index.html이 응답되로록 설정 되어 있음
  - 정적 데이터를 요청: naver.com/data/data.json
  - 동적 데이터 요청: ajax or REST API

## HTTP 1.1과 HTTP 2.0

---

- HTTP(HyperText Transfer Protocol): 웹에서 브라우저와 통신하기 위한 프로토콜
- HTTP 1.1: 요청과 응답은 `하나만` 처리 가능
- HTTP 2.0: `다중` 요청, 응답 처리 가능

## HTML 파싱과 DOM 생성

---

`브라우저 렌더링 엔진: HTML 문서 파싱 → DOM(Document Object Model) 생성`

1. 서버에 존재하는 HTML 문서를 메모리에 저장하여 `바이트`(2진수)를 인터넷에 경유하여 응답
2. 브라우저는 응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 (UTF-8) 인코딩 방식 기준으로 `문자열`로 변환
3. 문자열로 변환된 HTML 문서를 `토큰`으로 분해
4. 각 토큰 → 객체 변환 → `노드` 생성 (요소 노드, 문서 노드, 텍스트 노드)
5. `DOM`은 **중첩 관계**이며 **트리 자료구조**

## CSS 파싱과 CSSOM생성

---

`브라우저 렌더링 엔진: CSS 문서 파싱 → CSSOM(CSS Object Model) 생성`

- DOM을 생성하다 CSS를 로드하는 link태그나 style태그를 만나면 DOM 생성을 일시 중단
- 브라우저와 동일한 파싱 과정 (바이트 → 문자 → 토큰 → 노드 → CSSOM)

## 렌더 트리 생성

---

HTML 파싱 → DOM + CSS 파싱 → CSSOM ⇒ 렌더 트리 결합

`렌더 트리`

- 각 HTML 요소의 `레이아웃`을 `계산`하는 데 사용
- 브라우저 화면에 픽셀을 렌더링하는 `페인팅 처리`에 입력됨

## 자바스크립트 파싱과 실행

---

HTML 문서를 파싱한 결과인 `DOM`은 `DOM API`를 이용해서 `동적`으로 요소와 스타일 등을 변경 가능

`자바스크립트 엔진`

1. 자바스크립트 `파싱`(CPU가 이해할 수 있는 저수준언어로 변환)
2. `AST`(Abstract Syntax Tree) 생성
3. 중간 코드인 `바이트코드` 생성하여 실행

**토크나이징**

문자열인 자바스크립트 소스코드를 어휘 분석하여 문법적 의미를 갖는 코드의 최소 단위인 `토큰`들로 분해

**파싱**

토큰들의 집합을 구분 분석 → `AST` 생성

AST를 사용 → TypeScript, Babel, Prettier 같은 트랜스파일러 구현 가능

**바이트코드 생성과 실행**

파싱의 결과물로 생성된 AST를 중간 코드인 `바이트코드`로 변환하고 실행

## 리플로우와 리페인트

---

- 변경된 DOM과 CSSOM이 다시 렌더 트리에 결합되면 이를 기반으로 `레이아웃과 페인트 과정`을 다시 거쳐 브라우저의 화면에 `다시 렌더링`하는 것
- `리플로우`: 레이아웃 재계산 (레이아웃에 영향을 준 경우)
- `리페인트`: 재결합된 렌더 트리를 기반으로 다시 페인트 함

## 자바스크립트 파싱에 의한 HTML 파싱 중단

---

- 브라우저는 동기적으로 파싱/실행
- script 태그의 위치에 따라 HTML 파싱이 블로킹 → DOM 생성이 지연
- script 태그가 HTML 태그보다 먼저 있으면 DOM이 생성 완료 되기 전에 script 태그가 실행되어 에러가 발생할 수 있음

HTML5부터 `async / defer` 키워드를 script 태그에 함께 사용하여 비동기적으로 수행할 수 있다.

**`async`**

HTML 파싱과 외부 자바스크립트 파일의 로드가 `비동기적`으로 동시에 진행

자바스크립트의 파싱과 실횅은 **로드가 완료된 직후 진행**되며, 이때 **HTML 파싱은 중단**

각 자바스크립트의 로드가 완료된 직후 파싱과 실행이 되기때문에 순서가 보장x

**`defer`**

HTML 파싱과 외부 자바스크립트 파일의 로드가 `비동기적`으로 동시에 진행

**DOM 생성이 완료된 직후 진행**
